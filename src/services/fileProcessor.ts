/**
 * File Processing Service for AI Chat
 * Handles file upload and content extraction for AI processing
 */

export interface FileContent {
  name: string;
  type: string;
  size: number;
  content: string;
  preview?: string; // For images
}

/**
 * ƒê·ªçc n·ªôi dung file text (txt, js, ts, css, html, etc.)
 * T√≠ch h·ª£p AI analysis cho code files
 */
async function readTextFile(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async e => {
      const content = e.target?.result as string;

      try {
        // Ph√¢n t√≠ch v·ªõi AI d·ª±a tr√™n lo·∫°i file
        const analysis = await analyzeTextFileWithAI(content, file.name);

        resolve(`[File: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üìÑ **N·ªôi dung file:**
\`\`\`${getFileLanguage(file.name)}
${content}
\`\`\`

ü§ñ **Ph√¢n t√≠ch AI:**
${analysis}`);
      } catch (error) {
        // Fallback n·∫øu kh√¥ng th·ªÉ ph√¢n t√≠ch v·ªõi AI
        console.warn('Kh√¥ng th·ªÉ ph√¢n t√≠ch file v·ªõi AI:', error);
        resolve(`[File: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üìÑ **N·ªôi dung file:**
\`\`\`${getFileLanguage(file.name)}
${content}
\`\`\`

üí° **File ƒë√£ ƒë∆∞·ª£c upload th√†nh c√¥ng. B·∫°n c√≥ th·ªÉ h·ªèi AI v·ªÅ n·ªôi dung n√†y.**`);
      }
    };
    reader.onerror = () => reject(new Error('Kh√¥ng th·ªÉ ƒë·ªçc file text'));
    reader.readAsText(file, 'UTF-8');
  });
}

/**
 * Ph√¢n t√≠ch file text v·ªõi AI d·ª±a tr√™n lo·∫°i file
 */
async function analyzeTextFileWithAI(
  content: string,
  fileName: string,
): Promise<string> {
  try {
    const {
      analyzeCodeWithGemini,
      analyzeHTMLWithGemini,
      analyzeJSONWithGemini,
      analyzeMarkdownWithGemini,
    } = await import('../services/ai/gemini');

    const language = getFileLanguage(fileName);

    // Ph√¢n t√≠ch d·ª±a tr√™n lo·∫°i file
    if (
      ['js', 'ts', 'jsx', 'tsx', 'py', 'java', 'cpp', 'c', 'php'].includes(
        language,
      )
    ) {
      return await analyzeCodeWithGemini(content, language);
    } else if (['html', 'css'].includes(language)) {
      return await analyzeHTMLWithGemini(content);
    } else if (language === 'json') {
      return await analyzeJSONWithGemini(content);
    } else if (language === 'md') {
      return await analyzeMarkdownWithGemini(content);
    } else {
      // Default analysis cho text files
      return `üìù **File text ƒë√£ ƒë∆∞·ª£c ƒë·ªçc th√†nh c√¥ng.**
N·ªôi dung: ${content.length > 200 ? content.substring(0, 200) + '...' : content}

üí° **B·∫°n c√≥ th·ªÉ h·ªèi AI v·ªÅ n·ªôi dung c·ª• th·ªÉ trong file n√†y.**`;
    }
  } catch (error) {
    console.error('Error analyzing text file with AI:', error);
    throw error;
  }
}

/**
 * L·∫•y ng√¥n ng·ªØ t·ª´ t√™n file
 */
function getFileLanguage(fileName: string): string {
  const ext = fileName.split('.').pop()?.toLowerCase();

  const languageMap: Record<string, string> = {
    js: 'javascript',
    ts: 'typescript',
    jsx: 'jsx',
    tsx: 'tsx',
    py: 'python',
    java: 'java',
    cpp: 'cpp',
    c: 'c',
    php: 'php',
    html: 'html',
    css: 'css',
    json: 'json',
    md: 'markdown',
    sql: 'sql',
    yaml: 'yaml',
    yml: 'yaml',
  };

  return languageMap[ext || ''] || 'text';
}

/**
 * ƒê·ªçc n·ªôi dung h√¨nh ·∫£nh v√† chuy·ªÉn th√†nh base64
 * T√≠ch h·ª£p v·ªõi Gemini Vision API ƒë·ªÉ ph√¢n t√≠ch n·ªôi dung h√¨nh ·∫£nh
 */
async function readImageFile(
  file: File,
): Promise<{ content: string; preview: string }> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async e => {
      const result = e.target?.result as string;

      try {
        // G·ªçi Gemini Vision API ƒë·ªÉ ph√¢n t√≠ch h√¨nh ·∫£nh
        const imageAnalysis = await analyzeImageWithGemini(result);

        resolve({
          content: `[H√¨nh ·∫£nh: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üì∏ **Ph√¢n t√≠ch h√¨nh ·∫£nh:**
${imageAnalysis}

üí° **L∆∞u √Ω:** AI ƒë√£ ph√¢n t√≠ch n·ªôi dung h√¨nh ·∫£nh n√†y. B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ chi ti·∫øt c·ª• th·ªÉ.`,
          preview: result,
        });
      } catch (error) {
        // N·∫øu kh√¥ng th·ªÉ ph√¢n t√≠ch v·ªõi AI, fallback v·ªÅ c√°ch c≈©
        console.warn('Kh√¥ng th·ªÉ ph√¢n t√≠ch h√¨nh ·∫£nh v·ªõi AI:', error);

        // Th·ª≠ ph√¢n t√≠ch c∆° b·∫£n v·ªõi AI text-based
        try {
          const basicAnalysis = await analyzeImageBasic(file.name, file.size);
          resolve({
            content: `[H√¨nh ·∫£nh: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üì∏ **Th√¥ng tin h√¨nh ·∫£nh:**
${basicAnalysis}

üí° **L∆∞u √Ω:** B·∫°n c√≥ th·ªÉ m√¥ t·∫£ h√¨nh ·∫£nh n√†y ƒë·ªÉ AI h·ªó tr·ª£ t·ªët h∆°n.`,
            preview: result,
          });
        } catch (fallbackError) {
          resolve({
            content: `[H√¨nh ·∫£nh: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üì∏ **H√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c upload th√†nh c√¥ng.**
B·∫°n c√≥ th·ªÉ m√¥ t·∫£ h√¨nh ·∫£nh n√†y ho·∫∑c h·ªèi AI v·ªÅ n·ªôi dung trong h√¨nh.`,
            preview: result,
          });
        }
      }
    };
    reader.onerror = () => reject(new Error('Kh√¥ng th·ªÉ ƒë·ªçc file h√¨nh ·∫£nh'));
    reader.readAsDataURL(file);
  });
}

/**
 * Ph√¢n t√≠ch h√¨nh ·∫£nh v·ªõi Gemini Vision API
 */
async function analyzeImageWithGemini(imageDataUrl: string): Promise<string> {
  try {
    // Import Gemini service dynamically ƒë·ªÉ tr√°nh circular dependency
    const { generateImageAnalysis } = await import('../services/ai/gemini');

    // Extract base64 data t·ª´ data URL
    const base64Data = imageDataUrl.split(',')[1];

    const analysis = await generateImageAnalysis(base64Data);
    return analysis;
  } catch (error) {
    console.error('Error analyzing image with Gemini:', error);
    throw error;
  }
}

/**
 * Ph√¢n t√≠ch h√¨nh ·∫£nh c∆° b·∫£n v·ªõi AI text-based
 */
async function analyzeImageBasic(
  fileName: string,
  fileSize: number,
): Promise<string> {
  try {
    const { analyzeMarkdownWithGemini } = await import('../services/ai/gemini');

    const metadata = `H√¨nh ·∫£nh: ${fileName}
K√≠ch th∆∞·ªõc: ${(fileSize / 1024).toFixed(1)} KB
Lo·∫°i: Image file

ƒê√¢y l√† m·ªôt h√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c upload. AI c√≥ th·ªÉ gi√∫p:
- H∆∞·ªõng d·∫´n c√°ch m√¥ t·∫£ h√¨nh ·∫£nh
- G·ª£i √Ω c√¢u h·ªèi v·ªÅ h√¨nh ·∫£nh
- H·ªó tr·ª£ ph√¢n t√≠ch n·ªôi dung khi ƒë∆∞·ª£c m√¥ t·∫£
- ƒê·ªÅ xu·∫•t c√°ch s·ª≠ d·ª•ng h√¨nh ·∫£nh trong h·ªçc t·∫≠p`;

    return await analyzeMarkdownWithGemini(metadata);
  } catch (error) {
    console.error('Error analyzing image basic:', error);
    return `üì∏ **H√¨nh ·∫£nh ƒë√£ ƒë∆∞·ª£c nh·∫≠n th√†nh c√¥ng.**

üí° **AI c√≥ th·ªÉ gi√∫p b·∫°n:**
- H∆∞·ªõng d·∫´n c√°ch m√¥ t·∫£ h√¨nh ·∫£nh
- G·ª£i √Ω c√¢u h·ªèi v·ªÅ h√¨nh ·∫£nh
- H·ªó tr·ª£ ph√¢n t√≠ch n·ªôi dung khi ƒë∆∞·ª£c m√¥ t·∫£

H√£y m√¥ t·∫£ h√¨nh ·∫£nh ƒë·ªÉ AI c√≥ th·ªÉ h·ªó tr·ª£ t·ªët h∆°n.`;
  }
}

/**
 * X·ª≠ l√Ω file PDF v·ªõi PDF.js
 */
async function readPdfFile(file: File): Promise<string> {
  try {
    // Import PDF.js dynamically
    const pdfjsLib = await import('pdfjs-dist');

    // Set worker source
    pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;

    // Read file as ArrayBuffer
    const arrayBuffer = await file.arrayBuffer();

    // Load PDF
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

    let fullText = '';

    // Extract text from all pages
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      const page = await pdf.getPage(pageNum);
      const textContent = await page.getTextContent();
      const pageText = textContent.items.map((item: any) => item.str).join(' ');
      fullText += `\n--- Trang ${pageNum} ---\n${pageText}\n`;
    }

    // Analyze PDF content with AI
    const analysis = await analyzePDFWithAI(fullText, file.name);

    return `[File PDF: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB - ${pdf.numPages} trang

üìÑ **N·ªôi dung PDF:**
${fullText.substring(0, 1000)}${fullText.length > 1000 ? '...' : ''}

ü§ñ **Ph√¢n t√≠ch AI:**
${analysis}`;
  } catch (error) {
    console.error('Error reading PDF:', error);
    return `[File PDF: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

‚ùå **Kh√¥ng th·ªÉ ƒë·ªçc n·ªôi dung PDF t·ª± ƒë·ªông.**
L·ªói: ${error instanceof Error ? error.message : 'Kh√¥ng x√°c ƒë·ªãnh'}

üí° **G·ª£i √Ω:** B·∫°n c√≥ th·ªÉ copy-paste n·ªôi dung t·ª´ PDF ho·∫∑c chuy·ªÉn ƒë·ªïi sang file text ƒë·ªÉ AI c√≥ th·ªÉ ph√¢n t√≠ch.`;
  }
}

/**
 * Ph√¢n t√≠ch n·ªôi dung PDF v·ªõi AI
 */
async function analyzePDFWithAI(
  content: string,
  fileName: string,
): Promise<string> {
  try {
    const { analyzeMarkdownWithGemini } = await import('../services/ai/gemini');

    const enhancedContent = `PDF Analysis for: ${fileName}

${content}

ƒê√¢y l√† n·ªôi dung t·ª´ file PDF "${fileName}". AI c√≥ th·ªÉ gi√∫p:
- T√≥m t·∫Øt n·ªôi dung ch√≠nh
- Tr√≠ch xu·∫•t th√¥ng tin quan tr·ªçng
- Ph√¢n t√≠ch v√† gi·∫£i th√≠ch n·ªôi dung
- Tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ n·ªôi dung PDF`;

    return await analyzeMarkdownWithGemini(enhancedContent);
  } catch (error) {
    console.error('Error analyzing PDF with AI:', error);
    return `üìÑ **PDF "${fileName}" ƒë√£ ƒë∆∞·ª£c ƒë·ªçc th√†nh c√¥ng.**
N·ªôi dung: ${content.length > 200 ? content.substring(0, 200) + '...' : content}

üí° **B·∫°n c√≥ th·ªÉ h·ªèi AI v·ªÅ n·ªôi dung c·ª• th·ªÉ trong PDF n√†y.**`;
  }
}

/**
 * X·ª≠ l√Ω file Word v·ªõi mammoth.js
 */
async function readWordFile(file: File): Promise<string> {
  try {
    // Import mammoth dynamically
    const mammoth = await import('mammoth');

    // Read file as ArrayBuffer
    const arrayBuffer = await file.arrayBuffer();

    // Convert Word to HTML
    const result = await mammoth.convertToHtml({ arrayBuffer });

    // Extract text content (remove HTML tags)
    const textContent = result.value
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim();

    // Analyze Word content with AI
    const analysis = await analyzeWordWithAI(textContent, file.name);

    return `[File Word: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üìù **N·ªôi dung Word:**
${textContent.substring(0, 1000)}${textContent.length > 1000 ? '...' : ''}

ü§ñ **Ph√¢n t√≠ch AI:**
${analysis}`;
  } catch (error) {
    console.error('Error reading Word file:', error);
    return `[File Word: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

‚ùå **Kh√¥ng th·ªÉ ƒë·ªçc n·ªôi dung Word t·ª± ƒë·ªông.**
L·ªói: ${error instanceof Error ? error.message : 'Kh√¥ng x√°c ƒë·ªãnh'}

üí° **G·ª£i √Ω:** B·∫°n c√≥ th·ªÉ copy-paste n·ªôi dung t·ª´ Word ho·∫∑c l∆∞u file d∆∞·ªõi d·∫°ng text ƒë·ªÉ AI c√≥ th·ªÉ ph√¢n t√≠ch.`;
  }
}

/**
 * Ph√¢n t√≠ch n·ªôi dung Word v·ªõi AI
 */
async function analyzeWordWithAI(
  content: string,
  fileName: string,
): Promise<string> {
  try {
    const { analyzeMarkdownWithGemini } = await import('../services/ai/gemini');

    const enhancedContent = `Word Document Analysis for: ${fileName}

${content}

ƒê√¢y l√† n·ªôi dung t·ª´ file Word "${fileName}". AI c√≥ th·ªÉ gi√∫p:
- T√≥m t·∫Øt n·ªôi dung ch√≠nh
- Ph√¢n t√≠ch c·∫•u tr√∫c document
- ƒê·ªÅ xu·∫•t c·∫£i thi·ªán n·ªôi dung
- Tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ n·ªôi dung document`;

    return await analyzeMarkdownWithGemini(enhancedContent);
  } catch (error) {
    console.error('Error analyzing Word with AI:', error);
    return `üìù **Word document "${fileName}" ƒë√£ ƒë∆∞·ª£c ƒë·ªçc th√†nh c√¥ng.**
N·ªôi dung: ${content.length > 200 ? content.substring(0, 200) + '...' : content}

üí° **B·∫°n c√≥ th·ªÉ h·ªèi AI v·ªÅ n·ªôi dung c·ª• th·ªÉ trong document n√†y.**`;
  }
}

/**
 * X·ª≠ l√Ω file Excel/CSV v·ªõi SheetJS
 */
async function readExcelFile(file: File): Promise<string> {
  try {
    if (file.name.toLowerCase().endsWith('.csv')) {
      // ƒê·ªçc file CSV nh∆∞ text file
      const content = await readTextFile(file);
      return content;
    } else {
      // Import SheetJS dynamically
      const XLSX = await import('xlsx');

      // Read file as ArrayBuffer
      const arrayBuffer = await file.arrayBuffer();

      // Parse Excel file
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });

      let excelContent = '';

      // Process each worksheet
      workbook.SheetNames.forEach(sheetName => {
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        excelContent += `\n--- Sheet: ${sheetName} ---\n`;

        // Convert to readable format
        jsonData.forEach((row: unknown, index: number) => {
          if (Array.isArray(row) && row.length > 0) {
            excelContent += `Row ${index + 1}: ${row.join(' | ')}\n`;
          }
        });
      });

      // Analyze Excel content with AI
      const analysis = await analyzeExcelWithAI(excelContent, file.name);

      return `[File Excel: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB - ${workbook.SheetNames.length} sheet(s)

üìä **N·ªôi dung Excel:**
${excelContent.substring(0, 1000)}${excelContent.length > 1000 ? '...' : ''}

ü§ñ **Ph√¢n t√≠ch AI:**
${analysis}`;
    }
  } catch (error) {
    console.error('Error reading Excel file:', error);
    return `[File Excel: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

‚ùå **Kh√¥ng th·ªÉ ƒë·ªçc n·ªôi dung Excel t·ª± ƒë·ªông.**
L·ªói: ${error instanceof Error ? error.message : 'Kh√¥ng x√°c ƒë·ªãnh'}

üí° **G·ª£i √Ω:** B·∫°n c√≥ th·ªÉ export file th√†nh CSV ho·∫∑c copy-paste d·ªØ li·ªáu ƒë·ªÉ AI c√≥ th·ªÉ ph√¢n t√≠ch.`;
  }
}

/**
 * Ph√¢n t√≠ch n·ªôi dung Excel v·ªõi AI
 */
async function analyzeExcelWithAI(
  content: string,
  fileName: string,
): Promise<string> {
  try {
    const { analyzeJSONWithGemini } = await import('../services/ai/gemini');

    const enhancedContent = `Excel Data Analysis for: ${fileName}

${content}

ƒê√¢y l√† d·ªØ li·ªáu t·ª´ file Excel "${fileName}". AI c√≥ th·ªÉ gi√∫p:
- Ph√¢n t√≠ch d·ªØ li·ªáu v√† xu h∆∞·ªõng
- T·∫°o b√°o c√°o v√† th·ªëng k√™
- ƒê·ªÅ xu·∫•t bi·ªÉu ƒë·ªì ph√π h·ª£p
- Tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ d·ªØ li·ªáu`;

    return await analyzeJSONWithGemini(enhancedContent);
  } catch (error) {
    console.error('Error analyzing Excel with AI:', error);
    return `üìä **Excel file "${fileName}" ƒë√£ ƒë∆∞·ª£c ƒë·ªçc th√†nh c√¥ng.**
N·ªôi dung: ${content.length > 200 ? content.substring(0, 200) + '...' : content}

üí° **B·∫°n c√≥ th·ªÉ h·ªèi AI v·ªÅ d·ªØ li·ªáu c·ª• th·ªÉ trong Excel n√†y.**`;
  }
}

/**
 * X·ª≠ l√Ω file PowerPoint
 */
async function readPowerPointFile(file: File): Promise<string> {
  try {
    // PowerPoint files are complex binary format, ch√∫ng ta s·∫Ω ph√¢n t√≠ch metadata
    const analysis = await analyzePowerPointWithAI(file.name, file.size);

    return `[File PowerPoint: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üìä **Th√¥ng tin file PowerPoint:**
- T√™n file: ${file.name}
- K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)} KB
- Lo·∫°i file: Microsoft PowerPoint Presentation

ü§ñ **Ph√¢n t√≠ch AI:**
${analysis}

üí° **L∆∞u √Ω:** ƒê·ªÉ AI c√≥ th·ªÉ ph√¢n t√≠ch n·ªôi dung chi ti·∫øt, b·∫°n c√≥ th·ªÉ:
1. Copy-paste n·ªôi dung t·ª´ slides
2. Export th√†nh PDF v√† upload l·∫°i
3. M√¥ t·∫£ n·ªôi dung slides cho AI`;
  } catch (error) {
    console.error('Error analyzing PowerPoint file:', error);
    return `[File PowerPoint: ${file.name}] - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üìä **File PowerPoint ƒë√£ ƒë∆∞·ª£c nh·∫≠n th√†nh c√¥ng.**
Hi·ªán t·∫°i ch∆∞a h·ªó tr·ª£ ƒë·ªçc n·ªôi dung PowerPoint t·ª± ƒë·ªông.

üí° **G·ª£i √Ω:** B·∫°n c√≥ th·ªÉ copy-paste n·ªôi dung t·ª´ slides ho·∫∑c export th√†nh file text ƒë·ªÉ AI c√≥ th·ªÉ ph√¢n t√≠ch.`;
  }
}

/**
 * Ph√¢n t√≠ch file PowerPoint v·ªõi AI
 */
async function analyzePowerPointWithAI(
  fileName: string,
  fileSize: number,
): Promise<string> {
  try {
    const { analyzeMarkdownWithGemini } = await import('../services/ai/gemini');

    const metadata = `File PowerPoint: ${fileName}
K√≠ch th∆∞·ªõc: ${(fileSize / 1024).toFixed(1)} KB
Lo·∫°i: Microsoft PowerPoint Presentation

ƒê√¢y l√† m·ªôt file PowerPoint. ƒê·ªÉ ph√¢n t√≠ch n·ªôi dung chi ti·∫øt, ng∆∞·ªùi d√πng c·∫ßn:
1. M√¥ t·∫£ n·ªôi dung slides
2. Copy-paste text t·ª´ slides
3. Export th√†nh PDF ƒë·ªÉ AI c√≥ th·ªÉ ƒë·ªçc

AI c√≥ th·ªÉ gi√∫p:
- T·∫°o outline cho presentation
- Vi·∫øt script cho slides
- ƒê·ªÅ xu·∫•t c·∫£i thi·ªán n·ªôi dung
- T·∫°o slide m·ªõi d·ª±a tr√™n y√™u c·∫ßu`;

    return await analyzeMarkdownWithGemini(metadata);
  } catch (error) {
    console.error('Error analyzing PowerPoint with AI:', error);
    return `üìä **File PowerPoint ƒë√£ ƒë∆∞·ª£c nh·∫≠n th√†nh c√¥ng.**

üí° **AI c√≥ th·ªÉ gi√∫p b·∫°n:**
- T·∫°o outline cho presentation
- Vi·∫øt script cho slides  
- ƒê·ªÅ xu·∫•t c·∫£i thi·ªán n·ªôi dung
- T·∫°o slide m·ªõi d·ª±a tr√™n y√™u c·∫ßu

H√£y m√¥ t·∫£ n·ªôi dung slides ho·∫∑c y√™u c·∫ßu c·ª• th·ªÉ ƒë·ªÉ AI h·ªó tr·ª£ t·ªët h∆°n.`;
  }
}

/**
 * Ph√¢n t√≠ch file kh√¥ng x√°c ƒë·ªãnh v·ªõi AI
 */
async function analyzeUnknownFileWithAI(file: File): Promise<string> {
  try {
    const { analyzeMarkdownWithGemini } = await import('../services/ai/gemini');

    const metadata = `File: ${file.name}
Lo·∫°i: ${file.type || 'Kh√¥ng x√°c ƒë·ªãnh'}
K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)} KB
Extension: ${file.name.split('.').pop()?.toLowerCase() || 'kh√¥ng c√≥'}

ƒê√¢y l√† m·ªôt file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·ªçc n·ªôi dung t·ª± ƒë·ªông. AI c√≥ th·ªÉ gi√∫p:
1. ƒê·ªÅ xu·∫•t c√°ch x·ª≠ l√Ω file n√†y
2. G·ª£i √Ω c√¥ng c·ª• ph√π h·ª£p ƒë·ªÉ m·ªü file
3. H∆∞·ªõng d·∫´n chuy·ªÉn ƒë·ªïi sang format ƒë∆∞·ª£c h·ªó tr·ª£
4. Ph√¢n t√≠ch metadata v√† ƒë∆∞a ra l·ªùi khuy√™n`;

    return await analyzeMarkdownWithGemini(metadata);
  } catch (error) {
    console.error('Error analyzing unknown file with AI:', error);
    return `üìÅ **File kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·ªçc t·ª± ƒë·ªông.**

üí° **AI c√≥ th·ªÉ gi√∫p b·∫°n:**
- ƒê·ªÅ xu·∫•t c√°ch x·ª≠ l√Ω file n√†y
- G·ª£i √Ω c√¥ng c·ª• ph√π h·ª£p ƒë·ªÉ m·ªü file
- H∆∞·ªõng d·∫´n chuy·ªÉn ƒë·ªïi sang format ƒë∆∞·ª£c h·ªó tr·ª£

H√£y m√¥ t·∫£ file ho·∫∑c y√™u c·∫ßu c·ª• th·ªÉ ƒë·ªÉ AI h·ªó tr·ª£ t·ªët h∆°n.`;
  }
}

/**
 * Ph√°t hi·ªán lo·∫°i file v√† x·ª≠ l√Ω ph√π h·ª£p
 */
export async function processFile(file: File): Promise<FileContent> {
  const maxSize = 10 * 1024 * 1024; // 10MB

  if (file.size > maxSize) {
    throw new Error('File qu√° l·ªõn (t·ªëi ƒëa 10MB)');
  }

  const fileContent: FileContent = {
    name: file.name,
    type: file.type,
    size: file.size,
    content: '',
  };

  try {
    // Text files
    if (
      file.type.startsWith('text/') ||
      file.name.match(
        /\.(txt|js|ts|jsx|tsx|css|html|xml|json|md|py|java|cpp|c|php|sql|yaml|yml|ini|conf|log)$/i,
      )
    ) {
      fileContent.content = await readTextFile(file);
    }
    // Image files
    else if (file.type.startsWith('image/')) {
      const { content, preview } = await readImageFile(file);
      fileContent.content = content;
      fileContent.preview = preview;
    }
    // PDF files
    else if (file.type === 'application/pdf') {
      fileContent.content = await readPdfFile(file);
    }
    // Word files
    else if (file.type.includes('word') || file.name.match(/\.(doc|docx)$/i)) {
      fileContent.content = await readWordFile(file);
    }
    // Excel/CSV files
    else if (
      file.type.includes('spreadsheet') ||
      file.type.includes('excel') ||
      file.name.match(/\.(xlsx|xls|csv)$/i)
    ) {
      fileContent.content = await readExcelFile(file);
    }
    // PowerPoint files
    else if (
      file.type.includes('presentation') ||
      file.name.match(/\.(ppt|pptx)$/i)
    ) {
      fileContent.content = await readPowerPointFile(file);
    }
    // Archive files (zip, rar, etc.) - kh√¥ng h·ªó tr·ª£
    else if (
      file.type.includes('zip') ||
      file.type.includes('rar') ||
      file.type.includes('7z') ||
      file.name.match(/\.(zip|rar|7z|tar|gz)$/i)
    ) {
      throw new Error(
        'File n√©n (zip, rar, 7z) kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Vui l√≤ng gi·∫£i n√©n v√† g·ª≠i file ri√™ng l·∫ª.',
      );
    }
    // Other files
    else {
      // Th·ª≠ ph√¢n t√≠ch v·ªõi AI d·ª±a tr√™n metadata
      try {
        const analysis = await analyzeUnknownFileWithAI(file);
        fileContent.content = `[File: ${file.name}] - Lo·∫°i: ${file.type || 'Kh√¥ng x√°c ƒë·ªãnh'} - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB

üìÅ **Th√¥ng tin file:**
- T√™n: ${file.name}
- Lo·∫°i: ${file.type || 'Kh√¥ng x√°c ƒë·ªãnh'}
- K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)} KB

ü§ñ **Ph√¢n t√≠ch AI:**
${analysis}

üí° **G·ª£i √Ω:** C√°c lo·∫°i file ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·∫ßy ƒë·ªß: text, code, h√¨nh ·∫£nh, PDF, Word, Excel, PowerPoint.
B·∫°n c√≥ th·ªÉ copy-paste n·ªôi dung v√†o tin nh·∫Øn ƒë·ªÉ AI ph√¢n t√≠ch chi ti·∫øt h∆°n.`;
      } catch (error) {
        fileContent.content = `[File: ${file.name}] - Lo·∫°i: ${file.type || 'Kh√¥ng x√°c ƒë·ªãnh'} - K√≠ch th∆∞·ªõc: ${(file.size / 1024).toFixed(1)}KB
      
      File n√†y ch∆∞a ƒë∆∞·ª£c h·ªó tr·ª£ ƒë·ªçc n·ªôi dung t·ª± ƒë·ªông. 
      C√°c lo·∫°i file ƒë∆∞·ª£c h·ªó tr·ª£: text, code, h√¨nh ·∫£nh, PDF, Word, Excel, PowerPoint.
      B·∫°n c√≥ th·ªÉ copy-paste n·ªôi dung v√†o tin nh·∫Øn ƒë·ªÉ AI ph√¢n t√≠ch.`;
      }
    }

    return fileContent;
  } catch (error) {
    throw new Error(
      `L·ªói x·ª≠ l√Ω file: ${error instanceof Error ? error.message : 'Kh√¥ng x√°c ƒë·ªãnh'}`,
    );
  }
}

/**
 * Format file content cho AI prompt
 */
export function formatFileForAI(
  fileContent: FileContent,
  userMessage: string,
): string {
  const separator = '\n' + '='.repeat(50) + '\n';

  let prompt = `Ng∆∞·ªùi d√πng ƒë√£ g·ª≠i m·ªôt file k√®m tin nh·∫Øn. H√£y ph√¢n t√≠ch n·ªôi dung file v√† tr·∫£ l·ªùi theo y√™u c·∫ßu.

üìÅ **Th√¥ng tin file:**
- T√™n: ${fileContent.name}
- Lo·∫°i: ${fileContent.type}
- K√≠ch th∆∞·ªõc: ${(fileContent.size / 1024).toFixed(1)}KB

üí¨ **Tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng:**
${userMessage}

${separator}
üìÑ **N·ªôi dung file:**
${fileContent.content}
${separator}

H√£y ph√¢n t√≠ch file v√† tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng m·ªôt c√°ch chi ti·∫øt v√† h·ªØu √≠ch.`;

  return prompt;
}

/**
 * T·∫°o preview message cho UI
 */
export function createFilePreviewMessage(
  fileContent: FileContent,
  userMessage: string,
): string {
  const fileEmoji = getFileEmoji(fileContent.type, fileContent.name);

  let message = `${fileEmoji} **${fileContent.name}** (${(fileContent.size / 1024).toFixed(1)}KB)`;

  if (userMessage.trim()) {
    message += `\n\n${userMessage}`;
  }

  return message;
}

/**
 * L·∫•y emoji ph√π h·ª£p cho lo·∫°i file
 */
function getFileEmoji(type: string, name: string): string {
  if (type.startsWith('image/')) return 'üñºÔ∏è';
  if (type.includes('pdf')) return 'üìÑ';
  if (type.includes('word') || name.match(/\.(doc|docx)$/i)) return 'üìù';
  if (type.startsWith('text/') || name.match(/\.(txt|md)$/i)) return 'üìÉ';
  if (name.match(/\.(js|ts|jsx|tsx|css|html)$/i)) return 'üíª';
  if (name.match(/\.(json|xml)$/i)) return 'üìä';
  if (name.match(/\.(xlsx|xls|csv)$/i)) return 'üìä';
  if (name.match(/\.(ppt|pptx)$/i)) return 'üìä';
  if (name.match(/\.(py|java|cpp|c|php|sql)$/i)) return 'üíª';
  if (name.match(/\.(zip|rar|7z|tar|gz)$/i)) return 'üóúÔ∏è';
  return 'üìÅ';
}
